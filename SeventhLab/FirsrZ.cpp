//#include <iostream>
//#include <vector>
//#include <algorithm>
//
//using namespace std;
//
//const int INF = 1e9; // Константа для представления бесконечности
//
//// Функция для нахождения кратчайшего гамильтонова цикла методом динамического программирования
//static int tsp(int pos, int mask, const vector<vector<int>>& graph, vector<vector<int>>& dp, vector<vector<int>>& prev) {
//    int n = graph.size(); // Количество городов в графе
//
//    
//    if (mask == (1 << n) - 1)
//        return 0;//graph[pos][0]; // Вернуть стоимость возврата в начальный город
//
//    // Если уже рассчитано значение для данной позиции и маски, возвращаем его
//    if (dp[pos][mask] != -1)
//        return dp[pos][mask];
//
//    int ans = INF; // Инициализация ответа как бесконечности
//    int bestNext = -1; // Лучший следующий город для посещения
//
//    // Перебираем все возможные следующие города
//    for (int next = 0; next < n; ++next) {
//        // Если город еще не посещен
//        if (!(mask & (1 << next))) {
//            // Рекурсивно вызываем tsp для следующего города
//            int newAns = graph[pos][next] + tsp(next, mask | (1 << next), graph, dp, prev);
//            // Обновляем ответ, если новый путь короче
//            if (newAns < ans) {
//                ans = newAns;
//                bestNext = next;
//            }
//        }
//    }
//
//    // Запоминаем лучшего следующего города для данной позиции и маски
//    prev[pos][mask] = bestNext;
//    // Запоминаем рассчитанное значение для данной позиции и маски
//    return dp[pos][mask] = ans;
//}
//
//// Функция для вывода кратчайшего пути
//static void printPath(int pos, int mask, const vector<vector<int>>& prev) {
//    // Если все города уже посещены, выводим последний город и завершаем функцию
//    if (mask == (1 << prev.size()) - 1) {
//        cout << pos << " ";
//        return;
//    }
//
//    // Получаем следующий город по пути
//    int next = prev[pos][mask];
//    // Выводим текущий город
//    cout << pos << " ";
//    // Рекурсивно вызываем функцию для следующего города
//    printPath(next, mask | (1 << next), prev);
//}
//
//// Основная функция программы
//int main() {
//    setlocale(LC_ALL, "ru"); // Устанавливаем локаль для вывода на русском языке
//
//    // Инициализация весов рёбер графа
//    vector<vector<int>> graph = {
//        {0, 40, 65, 2},
//        {40, 0, 35, 25},
//        {65, 35, 0, 30},
//        {2, 25, 30, 0}
//    };
//
//    int n = graph.size(); // Количество городов
//
//    // Инициализация массивов для динамики и восстановления пути
//    vector<vector<int>> dp(n, vector<int>(1 << n, -1));
//    vector<vector<int>> prev(n, vector<int>(1 << n, -1));
//
//    // Вызываем функцию для нахождения кратчайшего гамильтонова цикла, начиная с города 0
//    int ans = tsp(0, 1, graph, dp, prev);
//
//    // Выводим минимальную стоимость обхода всех городов
//    cout << "Минимальная стоимость обхода всех городов: " << ans << endl;
//
//    // Выводим минимальный путь
//    cout << "Минимальный путь: ";
//    printPath(0, 1, prev);
//    cout << endl;
//
//    return 0;
//}
